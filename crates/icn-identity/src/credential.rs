use std::collections::HashMap;

use ed25519_dalek::{SigningKey, VerifyingKey};
use serde::{Deserialize, Serialize};

use icn_common::{Cid, CommonError, Did};

use crate::{sign_message, verify_signature, SignatureBytes};

/// A verifiable credential issued by a DID subject to selective disclosure.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Credential {
    /// DID of the issuer.
    pub issuer: Did,
    /// DID of the credential holder.
    pub holder: Did,
    /// Arbitrary claims asserted by the issuer.
    pub claims: HashMap<String, String>,
    /// Optional credential schema reference.
    pub schema: Option<Cid>,
    /// Per-claim signatures generated by the issuer.
    pub signatures: HashMap<String, SignatureBytes>,
}

impl Credential {
    /// Create a new unsigned credential.
    pub fn new(
        issuer: Did,
        holder: Did,
        claims: HashMap<String, String>,
        schema: Option<Cid>,
    ) -> Self {
        Self {
            issuer,
            holder,
            claims,
            schema,
            signatures: HashMap::new(),
        }
    }

    /// Sign all claims individually using the issuer's key.
    pub fn sign_claims(&mut self, key: &SigningKey) {
        for (k, v) in &self.claims {
            let mut bytes = self.issuer.to_string().into_bytes();
            bytes.extend_from_slice(self.holder.to_string().as_bytes());
            bytes.extend_from_slice(k.as_bytes());
            bytes.extend_from_slice(v.as_bytes());
            let sig = sign_message(key, &bytes);
            self
                .signatures
                .insert(k.clone(), SignatureBytes::from_ed_signature(sig));
        }
    }

    /// Verify a single claim against the issuer's verifying key.
    pub fn verify_claim(&self, claim: &str, key: &VerifyingKey) -> Result<(), CommonError> {
        let value = self
            .claims
            .get(claim)
            .ok_or_else(|| CommonError::IdentityError(format!("claim not found: {claim}")))?;
        let sig = self
            .signatures
            .get(claim)
            .ok_or_else(|| CommonError::IdentityError(format!("missing signature for claim: {claim}")))?;
        let mut bytes = self.issuer.to_string().into_bytes();
        bytes.extend_from_slice(self.holder.to_string().as_bytes());
        bytes.extend_from_slice(claim.as_bytes());
        bytes.extend_from_slice(value.as_bytes());
        let ed = sig.to_ed_signature()?;
        if verify_signature(key, &bytes, &ed) {
            Ok(())
        } else {
            Err(CommonError::IdentityError("claim signature invalid".into()))
        }
    }

    /// Create a disclosure containing only the specified claim names.
    pub fn selective_disclosure(&self, fields: &[&str]) -> DisclosedCredential {
        let mut claims = HashMap::new();
        let mut signatures = HashMap::new();
        for field in fields {
            if let Some(v) = self.claims.get(*field) {
                claims.insert((*field).to_string(), v.clone());
            }
            if let Some(sig) = self.signatures.get(*field) {
                signatures.insert((*field).to_string(), sig.clone());
            }
        }
        DisclosedCredential {
            issuer: self.issuer.clone(),
            holder: self.holder.clone(),
            claims,
            schema: self.schema.clone(),
            signatures,
        }
    }
}

/// A credential containing only a subset of claims.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct DisclosedCredential {
    /// DID of the issuer.
    pub issuer: Did,
    /// DID of the credential holder.
    pub holder: Did,
    /// Disclosed claims.
    pub claims: HashMap<String, String>,
    /// Optional schema reference.
    pub schema: Option<Cid>,
    /// Signatures for disclosed claims.
    pub signatures: HashMap<String, SignatureBytes>,
}

impl DisclosedCredential {
    /// Verify all disclosed claim signatures against the issuer key.
    pub fn verify(&self, key: &VerifyingKey) -> Result<(), CommonError> {
        for (k, v) in &self.claims {
            let sig = self
                .signatures
                .get(k)
                .ok_or_else(|| CommonError::IdentityError(format!("missing signature for claim: {k}")))?;
            let mut bytes = self.issuer.to_string().into_bytes();
            bytes.extend_from_slice(self.holder.to_string().as_bytes());
            bytes.extend_from_slice(k.as_bytes());
            bytes.extend_from_slice(v.as_bytes());
            let ed = sig.to_ed_signature()?;
            if !verify_signature(key, &bytes, &ed) {
                return Err(CommonError::IdentityError(format!("invalid signature for claim: {k}")));
            }
        }
        Ok(())
    }
}

