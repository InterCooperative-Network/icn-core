use std::collections::{HashMap, HashSet};

use ed25519_dalek::{SigningKey, VerifyingKey};
use serde::{Deserialize, Serialize};

use icn_common::{Cid, CommonError, Did};

#[cfg(test)]
use crate::zk::Groth16KeyManager;
use crate::zk::{Groth16Circuit, Groth16Prover};
use crate::zk::{ZkError, ZkProver};
use crate::{sign_message, verify_signature, SignatureBytes};
use icn_common::ZkCredentialProof;

/// A verifiable credential issued by a DID subject to selective disclosure.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Credential {
    /// DID of the issuer.
    pub issuer: Did,
    /// DID of the credential holder.
    pub holder: Did,
    /// Arbitrary claims asserted by the issuer.
    pub claims: HashMap<String, String>,
    /// Optional credential schema reference.
    pub schema: Option<Cid>,
    /// Per-claim signatures generated by the issuer.
    pub signatures: HashMap<String, SignatureBytes>,
    /// Claims that should remain private when sharing the credential.
    pub private_fields: HashSet<String>,
    /// Optional expiration timestamp as seconds since the Unix epoch.
    pub expires_at: Option<u64>,
}

impl Credential {
    /// Create a new unsigned credential.
    pub fn new(
        issuer: Did,
        holder: Did,
        claims: HashMap<String, String>,
        schema: Option<Cid>,
    ) -> Self {
        Self {
            issuer,
            holder,
            claims,
            schema,
            signatures: HashMap::new(),
            private_fields: HashSet::new(),
            expires_at: None,
        }
    }

    /// Sign all claims individually using the issuer's key.
    pub fn sign_claims(&mut self, key: &SigningKey) {
        for (k, v) in &self.claims {
            let mut bytes = self.issuer.to_string().into_bytes();
            bytes.extend_from_slice(self.holder.to_string().as_bytes());
            bytes.extend_from_slice(k.as_bytes());
            bytes.extend_from_slice(v.as_bytes());
            let sig = sign_message(key, &bytes);
            self.signatures
                .insert(k.clone(), SignatureBytes::from_ed_signature(sig));
        }
    }

    /// Returns `true` if the credential is expired.
    pub fn is_expired(&self) -> bool {
        if let Some(ts) = self.expires_at {
            chrono::Utc::now().timestamp() as u64 >= ts
        } else {
            false
        }
    }

    /// Verify a single claim against the issuer's verifying key.
    pub fn verify_claim(&self, claim: &str, key: &VerifyingKey) -> Result<(), CommonError> {
        if self.is_expired() {
            return Err(CommonError::IdentityError("credential expired".into()));
        }
        let value = self
            .claims
            .get(claim)
            .ok_or_else(|| CommonError::IdentityError(format!("claim not found: {claim}")))?;
        let sig = self.signatures.get(claim).ok_or_else(|| {
            CommonError::IdentityError(format!("missing signature for claim: {claim}"))
        })?;
        let mut bytes = self.issuer.to_string().into_bytes();
        bytes.extend_from_slice(self.holder.to_string().as_bytes());
        bytes.extend_from_slice(claim.as_bytes());
        bytes.extend_from_slice(value.as_bytes());
        let ed = sig.to_ed_signature()?;
        if verify_signature(key, &bytes, &ed) {
            Ok(())
        } else {
            Err(CommonError::IdentityError("claim signature invalid".into()))
        }
    }

    /// Create a disclosure containing only the specified claim names.
    pub fn selective_disclosure(&self, fields: &[&str]) -> DisclosedCredential {
        let mut claims = HashMap::new();
        let mut signatures = HashMap::new();
        for field in fields {
            if let Some(v) = self.claims.get(*field) {
                claims.insert((*field).to_string(), v.clone());
            }
            if let Some(sig) = self.signatures.get(*field) {
                signatures.insert((*field).to_string(), sig.clone());
            }
        }
        DisclosedCredential {
            issuer: self.issuer.clone(),
            holder: self.holder.clone(),
            claims,
            schema: self.schema.clone(),
            signatures,
            expires_at: self.expires_at,
        }
    }

    /// Disclose a subset of fields and generate a proof for the rest.
    pub fn disclose_with_proof(
        &self,
        fields: &[&str],
        prover: &dyn ZkProver,
    ) -> Result<(DisclosedCredential, ZkCredentialProof), ZkError> {
        if self.is_expired() {
            return Err(ZkError::VerificationFailed);
        }
        let disclosed = self.selective_disclosure(fields);
        let undisclosed: Vec<&str> = self
            .claims
            .keys()
            .filter(|k| !fields.contains(&k.as_str()))
            .map(|k| k.as_str())
            .collect();
        let proof = prover.prove(self, &undisclosed)?;
        Ok((disclosed, proof))
    }
}

/// A credential containing only a subset of claims.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct DisclosedCredential {
    /// DID of the issuer.
    pub issuer: Did,
    /// DID of the credential holder.
    pub holder: Did,
    /// Disclosed claims.
    pub claims: HashMap<String, String>,
    /// Optional schema reference.
    pub schema: Option<Cid>,
    /// Signatures for disclosed claims.
    pub signatures: HashMap<String, SignatureBytes>,
    /// Optional expiration timestamp carried from the original credential.
    pub expires_at: Option<u64>,
}

impl DisclosedCredential {
    /// Verify all disclosed claim signatures against the issuer key.
    pub fn verify(&self, key: &VerifyingKey) -> Result<(), CommonError> {
        if let Some(ts) = self.expires_at {
            if chrono::Utc::now().timestamp() as u64 >= ts {
                return Err(CommonError::IdentityError("credential expired".into()));
            }
        }
        for (k, v) in &self.claims {
            let sig = self.signatures.get(k).ok_or_else(|| {
                CommonError::IdentityError(format!("missing signature for claim: {k}"))
            })?;
            let mut bytes = self.issuer.to_string().into_bytes();
            bytes.extend_from_slice(self.holder.to_string().as_bytes());
            bytes.extend_from_slice(k.as_bytes());
            bytes.extend_from_slice(v.as_bytes());
            let ed = sig.to_ed_signature()?;
            if !verify_signature(key, &bytes, &ed) {
                return Err(CommonError::IdentityError(format!(
                    "invalid signature for claim: {k}"
                )));
            }
        }
        Ok(())
    }

    /// Returns `true` if the credential is expired.
    pub fn is_expired(&self) -> bool {
        if let Some(ts) = self.expires_at {
            chrono::Utc::now().timestamp() as u64 >= ts
        } else {
            false
        }
    }
}

pub struct CredentialIssuer {
    did: Did,
    signing_key: SigningKey,
    prover: Option<Box<dyn ZkProver>>,
}

impl CredentialIssuer {
    pub fn new(did: Did, signing_key: SigningKey) -> Self {
        Self {
            did,
            signing_key,
            prover: None,
        }
    }

    pub fn with_prover(mut self, prover: Box<dyn ZkProver>) -> Self {
        self.prover = Some(prover);
        self
    }

    pub fn issue(
        &self,
        holder: Did,
        claims: HashMap<String, String>,
        schema: Option<Cid>,
        prove_fields: Option<&[&str]>,
        circuit: Option<Groth16Circuit>,
        private_fields: Option<&[&str]>,
    ) -> Result<(Credential, Option<ZkCredentialProof>), ZkError> {
        let mut cred = Credential::new(self.did.clone(), holder, claims, schema);
        if let Some(pf) = private_fields {
            cred.private_fields = pf.iter().map(|f| f.to_string()).collect();
        }
        cred.sign_claims(&self.signing_key);
        let proof = if let (Some(ref prover), Some(fields)) = (&self.prover, prove_fields) {
            if let Some(groth16) = prover.as_any().downcast_ref::<Groth16Prover>() {
                if let Some(c) = circuit {
                    Some(groth16.prove_with_circuit(&cred, fields, c)?)
                } else {
                    Some(groth16.prove(&cred, fields)?)
                }
            } else {
                Some(prover.prove(&cred, fields)?)
            }
        } else {
            None
        };
        crate::metrics::CREDENTIALS_ISSUED.inc();
        Ok((cred, proof))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generate_ed25519_keypair;
    use crate::zk::{
        BulletproofsProver, BulletproofsVerifier, DummyProver, DummyVerifier, Groth16Circuit,
        Groth16Prover, Groth16Verifier, ZkVerifier,
    };

    #[test]
    fn dummy_proof_roundtrip() {
        let (sk, _) = generate_ed25519_keypair();
        let issuer = Did::new("key", "issuer");
        let holder = Did::new("key", "holder");
        let mut claims = HashMap::new();
        claims.insert("age".to_string(), "30".to_string());

        let issuer = CredentialIssuer::new(issuer, sk).with_prover(Box::new(DummyProver));
        let (_, proof_opt) = issuer
            .issue(
                holder,
                claims,
                Some(Cid::new_v1_sha256(0x55, b"schema")),
                Some(&["age"]),
                None,
                None,
            )
            .unwrap();
        let proof = proof_opt.expect("proof");
        let verifier = DummyVerifier;
        assert!(verifier.verify(&proof).unwrap());
    }

    #[test]
    fn bulletproofs_proof_roundtrip() {
        let (sk, _) = generate_ed25519_keypair();
        let issuer = Did::new("key", "issuer");
        let holder = Did::new("key", "holder");
        let mut claims = HashMap::new();
        claims.insert("amount".to_string(), "42".to_string());

        let issuer = CredentialIssuer::new(issuer, sk).with_prover(Box::new(BulletproofsProver));
        let (_, proof_opt) = issuer
            .issue(
                holder,
                claims,
                Some(Cid::new_v1_sha256(0x55, b"schema")),
                Some(&[]),
                None,
                None,
            )
            .unwrap();
        let proof = proof_opt.expect("proof");
        let verifier = BulletproofsVerifier;
        assert!(verifier.verify(&proof).unwrap());
    }

    #[test]
    fn groth16_proof_roundtrip() {
        let (sk, _) = generate_ed25519_keypair();
        let issuer = Did::new("key", "issuer");
        let holder = Did::new("key", "holder");
        let mut claims = HashMap::new();
        claims.insert("birth_year".to_string(), "2000".to_string());

        use crate::zk::key_manager::Groth16KeySource;
        use icn_zk::AgeOver18Circuit;

        let km = Groth16KeyManager::new(
            "age_over_18",
            Groth16KeySource::Circuit(AgeOver18Circuit {
                birth_year: 0,
                current_year: 0,
            }),
            &sk,
        )
        .unwrap();
        let prover = Groth16Prover::new(
            km.clone(),
            std::sync::Arc::new(icn_reputation::InMemoryReputationStore::new()),
            icn_zk::ReputationThresholds::default(),
        );
        let issuer = CredentialIssuer::new(issuer, sk).with_prover(Box::new(prover));
        let (_, proof_opt) = issuer
            .issue(
                holder,
                claims,
                Some(Cid::new_v1_sha256(0x55, b"schema")),
                Some(&[]),
                Some(Groth16Circuit::AgeOver18 { current_year: 2020 }),
                None,
            )
            .unwrap();
        let proof = proof_opt.expect("proof");
        let verifier = Groth16Verifier::new(
            icn_zk::prepare_vk(km.proving_key()),
            vec![ark_bn254::Fr::from(2020u64)],
            std::sync::Arc::new(icn_reputation::InMemoryReputationStore::new()),
            icn_zk::ReputationThresholds::default(),
        );
        assert!(verifier.verify(&proof).unwrap());
    }
}
