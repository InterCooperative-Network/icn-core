use std::collections::HashMap;

use ed25519_dalek::{SigningKey, VerifyingKey};
use serde::{Deserialize, Serialize};

use icn_common::{Cid, CommonError, Did};

use crate::zk::{Groth16Circuit, Groth16Prover};
use crate::zk::{ZkError, ZkProver};
use crate::{sign_message, verify_signature, SignatureBytes};
use icn_common::ZkCredentialProof;

/// A verifiable credential issued by a DID subject to selective disclosure.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Credential {
    /// DID of the issuer.
    pub issuer: Did,
    /// DID of the credential holder.
    pub holder: Did,
    /// Arbitrary claims asserted by the issuer.
    pub claims: HashMap<String, String>,
    /// Optional credential schema reference.
    pub schema: Option<Cid>,
    /// Per-claim signatures generated by the issuer.
    pub signatures: HashMap<String, SignatureBytes>,
}

impl Credential {
    /// Create a new unsigned credential.
    pub fn new(
        issuer: Did,
        holder: Did,
        claims: HashMap<String, String>,
        schema: Option<Cid>,
    ) -> Self {
        Self {
            issuer,
            holder,
            claims,
            schema,
            signatures: HashMap::new(),
        }
    }

    /// Sign all claims individually using the issuer's key.
    pub fn sign_claims(&mut self, key: &SigningKey) {
        for (k, v) in &self.claims {
            let mut bytes = self.issuer.to_string().into_bytes();
            bytes.extend_from_slice(self.holder.to_string().as_bytes());
            bytes.extend_from_slice(k.as_bytes());
            bytes.extend_from_slice(v.as_bytes());
            let sig = sign_message(key, &bytes);
            self.signatures
                .insert(k.clone(), SignatureBytes::from_ed_signature(sig));
        }
    }

    /// Verify a single claim against the issuer's verifying key.
    pub fn verify_claim(&self, claim: &str, key: &VerifyingKey) -> Result<(), CommonError> {
        let value = self
            .claims
            .get(claim)
            .ok_or_else(|| CommonError::IdentityError(format!("claim not found: {claim}")))?;
        let sig = self.signatures.get(claim).ok_or_else(|| {
            CommonError::IdentityError(format!("missing signature for claim: {claim}"))
        })?;
        let mut bytes = self.issuer.to_string().into_bytes();
        bytes.extend_from_slice(self.holder.to_string().as_bytes());
        bytes.extend_from_slice(claim.as_bytes());
        bytes.extend_from_slice(value.as_bytes());
        let ed = sig.to_ed_signature()?;
        if verify_signature(key, &bytes, &ed) {
            Ok(())
        } else {
            Err(CommonError::IdentityError("claim signature invalid".into()))
        }
    }

    /// Create a disclosure containing only the specified claim names.
    pub fn selective_disclosure(&self, fields: &[&str]) -> DisclosedCredential {
        let mut claims = HashMap::new();
        let mut signatures = HashMap::new();
        for field in fields {
            if let Some(v) = self.claims.get(*field) {
                claims.insert((*field).to_string(), v.clone());
            }
            if let Some(sig) = self.signatures.get(*field) {
                signatures.insert((*field).to_string(), sig.clone());
            }
        }
        DisclosedCredential {
            issuer: self.issuer.clone(),
            holder: self.holder.clone(),
            claims,
            schema: self.schema.clone(),
            signatures,
        }
    }
}

/// A credential containing only a subset of claims.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct DisclosedCredential {
    /// DID of the issuer.
    pub issuer: Did,
    /// DID of the credential holder.
    pub holder: Did,
    /// Disclosed claims.
    pub claims: HashMap<String, String>,
    /// Optional schema reference.
    pub schema: Option<Cid>,
    /// Signatures for disclosed claims.
    pub signatures: HashMap<String, SignatureBytes>,
}

impl DisclosedCredential {
    /// Verify all disclosed claim signatures against the issuer key.
    pub fn verify(&self, key: &VerifyingKey) -> Result<(), CommonError> {
        for (k, v) in &self.claims {
            let sig = self.signatures.get(k).ok_or_else(|| {
                CommonError::IdentityError(format!("missing signature for claim: {k}"))
            })?;
            let mut bytes = self.issuer.to_string().into_bytes();
            bytes.extend_from_slice(self.holder.to_string().as_bytes());
            bytes.extend_from_slice(k.as_bytes());
            bytes.extend_from_slice(v.as_bytes());
            let ed = sig.to_ed_signature()?;
            if !verify_signature(key, &bytes, &ed) {
                return Err(CommonError::IdentityError(format!(
                    "invalid signature for claim: {k}"
                )));
            }
        }
        Ok(())
    }
}

pub struct CredentialIssuer {
    did: Did,
    signing_key: SigningKey,
    prover: Option<Box<dyn ZkProver>>,
}

impl CredentialIssuer {
    pub fn new(did: Did, signing_key: SigningKey) -> Self {
        Self {
            did,
            signing_key,
            prover: None,
        }
    }

    pub fn with_prover(mut self, prover: Box<dyn ZkProver>) -> Self {
        self.prover = Some(prover);
        self
    }

    pub fn issue(
        &self,
        holder: Did,
        claims: HashMap<String, String>,
        schema: Option<Cid>,
        prove_fields: Option<&[&str]>,
        circuit: Option<Groth16Circuit>,
    ) -> Result<(Credential, Option<ZkCredentialProof>), ZkError> {
        let mut cred = Credential::new(self.did.clone(), holder, claims, schema);
        cred.sign_claims(&self.signing_key);
        let proof = if let (Some(ref prover), Some(fields)) = (&self.prover, prove_fields) {
            if let Some(groth16) = prover.as_any().downcast_ref::<Groth16Prover>() {
                if let Some(c) = circuit {
                    Some(groth16.prove_with_circuit(&cred, fields, c)?)
                } else {
                    Some(groth16.prove(&cred, fields)?)
                }
            } else {
                Some(prover.prove(&cred, fields)?)
            }
        } else {
            None
        };
        Ok((cred, proof))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generate_ed25519_keypair;
    use crate::zk::{
        BulletproofsProver, BulletproofsVerifier, DummyProver, DummyVerifier, Groth16Circuit,
        Groth16Prover, Groth16Verifier, ZkVerifier,
    };

    #[test]
    fn dummy_proof_roundtrip() {
        let (sk, _) = generate_ed25519_keypair();
        let issuer = Did::new("key", "issuer");
        let holder = Did::new("key", "holder");
        let mut claims = HashMap::new();
        claims.insert("age".to_string(), "30".to_string());

        let issuer = CredentialIssuer::new(issuer, sk).with_prover(Box::new(DummyProver));
        let (_, proof_opt) = issuer
            .issue(
                holder,
                claims,
                Some(Cid::new_v1_sha256(0x55, b"schema")),
                Some(&["age"]),
                None,
            )
            .unwrap();
        let proof = proof_opt.expect("proof");
        let verifier = DummyVerifier;
        assert!(verifier.verify(&proof).unwrap());
    }

    #[test]
    fn bulletproofs_proof_roundtrip() {
        let (sk, _) = generate_ed25519_keypair();
        let issuer = Did::new("key", "issuer");
        let holder = Did::new("key", "holder");
        let mut claims = HashMap::new();
        claims.insert("amount".to_string(), "42".to_string());

        let issuer = CredentialIssuer::new(issuer, sk).with_prover(Box::new(BulletproofsProver));
        let (_, proof_opt) = issuer
            .issue(
                holder,
                claims,
                Some(Cid::new_v1_sha256(0x55, b"schema")),
                Some(&[]),
                None,
            )
            .unwrap();
        let proof = proof_opt.expect("proof");
        let verifier = BulletproofsVerifier;
        assert!(verifier.verify(&proof).unwrap());
    }

    #[test]
    fn groth16_proof_roundtrip() {
        use ark_std::rand::{rngs::StdRng, SeedableRng};
        use icn_zk::{setup, AgeOver18Circuit};

        let (sk, _) = generate_ed25519_keypair();
        let issuer = Did::new("key", "issuer");
        let holder = Did::new("key", "holder");
        let mut claims = HashMap::new();
        claims.insert("birth_year".to_string(), "2000".to_string());

        let mut rng = StdRng::seed_from_u64(42);
        let pk = setup(
            AgeOver18Circuit {
                birth_year: 2000,
                current_year: 2020,
            },
            &mut rng,
        )
        .unwrap();

        let issuer =
            CredentialIssuer::new(issuer, sk).with_prover(Box::new(Groth16Prover::new(pk)));
        let (_, proof_opt) = issuer
            .issue(
                holder,
                claims,
                Some(Cid::new_v1_sha256(0x55, b"schema")),
                Some(&[]),
                Some(Groth16Circuit::AgeOver18 { current_year: 2020 }),
            )
            .unwrap();
        let proof = proof_opt.expect("proof");
        let verifier = Groth16Verifier::default();
        assert!(verifier.verify(&proof).unwrap());
    }
}
