// icn-ccl/src/grammar/ccl.pest
//
// This grammar defines the Cooperative Contract Language (CCL) syntax used by
// the compiler. It supports function definitions, policy `rule` statements with
// actions (`allow`, `deny`, `charge`), standard control flow and basic
// expressions. See `docs/CCL_LANGUAGE_REFERENCE.md` for an explanation of each
// construct and examples.

// Define whitespace and comments (parsed but ignored by default)
WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* }

// Basic building blocks
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
integer_literal = @{ ASCII_DIGIT+ }
// Strings may contain most punctuation and common escape sequences
// like \n, \t, \\ and \". Newlines are not allowed unescaped.
string_inner = { "\\" ~ ANY | !("\"" | NEWLINE) ~ ANY }
string_literal = @{ "\"" ~ string_inner* ~ "\"" }
boolean_literal = { "true" | "false" }

// Top-level: A CCL policy is a sequence of statements or definitions
policy = { SOI ~ (function_definition | policy_statement)* ~ EOI }

// Example: Function Definition
function_definition = { "fn" ~ identifier ~ "(" ~ (parameter ~ ("," ~ parameter)*)? ~ ")" ~ "->" ~ type_annotation ~ block }
parameter = { identifier ~ ":" ~ type_annotation }
type_annotation = { identifier } // NEW - type will be validated in Rust code

// Example: Policy Statement (e.g., a rule)
policy_statement = { rule_definition | import_statement }
rule_definition = { "rule" ~ identifier ~ "when" ~ expression ~ "then" ~ action }
import_statement = { "import" ~ string_literal ~ "as" ~ identifier ~ ";" }

// Example: Block of statements
block = { "{" ~ statement* ~ "}" }
statement = { let_statement | expression_statement | return_statement | if_statement | while_statement }
let_statement = { "let" ~ identifier ~ "=" ~ expression ~ ";" }
expression_statement = { expression ~ ";" }
return_statement = { "return" ~ expression ~ ";" }
if_statement = { "if" ~ expression ~ block ~ ("else" ~ block)? }
while_statement = { "while" ~ expression ~ block }

// Example: Expressions with proper precedence and unary operators
expression = { logical_or }
logical_or = { logical_and ~ (OR_OP ~ logical_and)* }
logical_and = { equality ~ (AND_OP ~ equality)* }
equality = { comparison ~ ((EQ_OP | NEQ_OP) ~ comparison)* }
comparison = { addition ~ ((LTE_OP | LT_OP | GTE_OP | GT_OP) ~ addition)* }
addition = { multiplication ~ ((ADD_OP | SUB_OP) ~ multiplication)* }
multiplication = { unary ~ ((MUL_OP | DIV_OP) ~ unary)* }
unary = { (NOT_OP | SUB_OP) ~ unary | primary }
primary = { atom ~ ("[" ~ expression ~ "]")* }
atom = { integer_literal | boolean_literal | string_literal | function_call | identifier | array_literal | "(" ~ expression ~ ")" }
array_literal = { "[" ~ expression ~ ("," ~ expression)* ~ "]" }
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

ADD_OP = { "+" }
SUB_OP = { "-" }
MUL_OP = { "*" }
DIV_OP = { "/" }
EQ_OP  = { "==" }
NEQ_OP = { "!=" }
LTE_OP = { "<=" }
LT_OP  = { "<" }
GTE_OP = { ">=" }
GT_OP  = { ">" }
AND_OP = { "&&" }
OR_OP  = { "||" }
NOT_OP = { "!" }

// Example: Actions (specific to policy rules)
action = { ALLOW | DENY | CHARGE ~ expression }
ALLOW = { "allow" }
DENY = { "deny" }
CHARGE = { "charge" }

// Catch-all for errors or further development
// UNEXPECTED = _{ ANY } // Uncomment for debugging grammar issues 